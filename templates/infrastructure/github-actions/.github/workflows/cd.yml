# CD Pipeline ‚Äî {project_name} MVP
#
# –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–∏:
#   - Push —Ç–µ–≥–∞ v*.*.* (–Ω–∞–ø—Ä–∏–º–µ—Ä, v1.0.0)
#   - –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ workflow_dispatch
#
# –≠—Ç–∞–ø—ã:
#   1. Build & Push Docker Images
#   2. Deploy to Staging
#   3. Deploy to Production (manual approval)

name: CD Pipeline

on:
  push:
    tags:
      - "v*.*.*"

  workflow_dispatch:
    inputs:
      environment:
        description: "–û–∫—Ä—É–∂–µ–Ω–∏–µ –¥–ª—è –¥–µ–ø–ª–æ—è"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}

jobs:
  # === –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ ===
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      services: ${{ steps.services.outputs.list }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get version
        id: version
        run: |
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            VERSION="dev-${GITHUB_SHA::8}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Version: ${VERSION}"

      - name: List services
        id: services
        run: |
          SERVICES=$(ls -d services/*/ | xargs -n1 basename | jq -R -s -c 'split("\n")[:-1]')
          echo "list=${SERVICES}" >> $GITHUB_OUTPUT

  # === –°–±–æ—Ä–∫–∞ –∏ –ø—É–±–ª–∏–∫–∞—Ü–∏—è –æ–±—Ä–∞–∑–æ–≤ ===
  build-push:
    name: Build & Push
    runs-on: ubuntu-latest
    needs: prepare

    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.services) }}

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/${{ matrix.service }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=

      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: services/${{ matrix.service }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.prepare.outputs.version }}

  # === –î–µ–ø–ª–æ–π –Ω–∞ Staging ===
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [prepare, build-push]
    environment:
      name: staging
      url: https://staging.{domain}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

      - name: Deploy to Staging
        env:
          HOST: ${{ secrets.STAGING_HOST }}
          USER: ${{ secrets.STAGING_USER }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          ssh -o StrictHostKeyChecking=no ${USER}@${HOST} << 'EOF'
            cd /opt/{context}

            # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–æ–≤
            export IMAGE_TAG="${VERSION}"

            # Pull –Ω–æ–≤—ã—Ö –æ–±—Ä–∞–∑–æ–≤
            docker compose pull

            # –î–µ–ø–ª–æ–π —Å zero-downtime
            docker compose up -d --remove-orphans

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º health
            sleep 10
            curl -f http://localhost:8000/health || exit 1

            # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –æ–±—Ä–∞–∑–æ–≤
            docker image prune -f
          EOF

      - name: Run Smoke Tests
        env:
          STAGING_URL: https://staging.{domain}
        run: |
          # –ü—Ä–æ—Å—Ç—ã–µ smoke —Ç–µ—Å—Ç—ã
          curl -f "${STAGING_URL}/health" || exit 1
          curl -f "${STAGING_URL}/api/v1/health" || exit 1
          echo "Smoke tests passed!"

      - name: Notify Success
        if: success()
        run: |
          echo "‚úÖ Staging deployment successful!"
          echo "Version: ${{ needs.prepare.outputs.version }}"

  # === –î–µ–ø–ª–æ–π –Ω–∞ Production ===
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [prepare, build-push, deploy-staging]
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    environment:
      name: production
      url: https://{domain}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

      - name: Deploy to Production
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          ssh -o StrictHostKeyChecking=no ${USER}@${HOST} << 'EOF'
            cd /opt/{context}

            # Backup —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            docker compose exec -T postgres pg_dump -U app {context}_db > /backups/pre-deploy-$(date +%Y%m%d-%H%M%S).sql

            # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–æ–≤
            export IMAGE_TAG="${VERSION}"

            # Pull –Ω–æ–≤—ã—Ö –æ–±—Ä–∞–∑–æ–≤
            docker compose -f docker-compose.yml -f docker-compose.prod.yml pull

            # Rolling update
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d --remove-orphans

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º health
            sleep 15
            curl -f http://localhost:8000/health || exit 1

            # –û—á–∏—Å—Ç–∫–∞
            docker image prune -f
          EOF

      - name: Verify Deployment
        env:
          PROD_URL: https://{domain}
        run: |
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å
          for i in {1..5}; do
            if curl -f "${PROD_URL}/health"; then
              echo "‚úÖ Production is healthy!"
              exit 0
            fi
            echo "Waiting for production to be ready..."
            sleep 10
          done
          echo "‚ùå Production health check failed!"
          exit 1

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: Release v${{ needs.prepare.outputs.version }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Success
        if: success()
        run: |
          echo "üöÄ Production deployment successful!"
          echo "Version: ${{ needs.prepare.outputs.version }}"
          echo "URL: https://{domain}"

  # === Rollback (—Ä—É—á–Ω–æ–π) ===
  rollback:
    name: Rollback
    runs-on: ubuntu-latest
    if: failure() && needs.deploy-production.result == 'failure'
    needs: deploy-production
    environment: production

    steps:
      - name: Rollback to previous version
        env:
          HOST: ${{ secrets.PRODUCTION_HOST }}
          USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          ssh -o StrictHostKeyChecking=no ${USER}@${HOST} << 'EOF'
            cd /opt/{context}

            # –û—Ç–∫–∞—Ç –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â—É—é –≤–µ—Ä—Å–∏—é
            docker compose -f docker-compose.yml -f docker-compose.prod.yml down

            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –±—ç–∫–∞–ø–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            # LATEST_BACKUP=$(ls -t /backups/*.sql | head -1)
            # docker compose exec -T postgres psql -U app {context}_db < ${LATEST_BACKUP}

            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º–∏ –æ–±—Ä–∞–∑–∞–º–∏
            docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
          EOF

      - name: Notify Rollback
        run: |
          echo "‚ö†Ô∏è Production rollback executed!"
